from multiprocessing import Pool
import numpy as np

def f(x,IDs):
    return x**2., IDs

# Prevents spawned processes from recursing.
if __name__ == "__main__":
    # Generate some dummy data.
    N = 100
    x = np.random.rand(N)
    
    # Spawn a number of processes equal to the number of processors
    # you have (detected automatically). Doing Pool(5) spawns 5.
    pool = Pool()
    nproc = pool._processes # Get number of processes that spawned.

    # Split up the data into chunks. np.array_split divides an
    # array into nproc parts as evenly as possible.
    c = np.array_split(np.arange(N),nproc) # Array of indices
    
    # Assign the processes a task. In this case, each process will
    # compute function f with x as the input as well as i, which we
    # will use to identify where the outputs should go once we get
    # them back from the processes.
    proc = [None]*nproc
    for i in range(0,nproc):
        proc[i] = pool.apply_async(f,args=(x,c[i]))
        
    # Tell the processes to compute f(x) and store the results in
    # an array called y. Note that processes can finish out of
    # order. We can make sure the results are being stored in the
    # correct part of the array by keeping track of the processes
    # in function f.
    y = np.zeros(N)
    for i in range(0,nproc):
        ytemp, IDs = proc[i].get()
        y[IDs] = ytemp

    pool.close() # Close the processes
